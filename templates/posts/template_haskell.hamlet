    <h1>
      <a #user-content-te-haskell .anchor href="file:///var/folders/6n/t563zg9s3v78qtnjndr5f5gh0000gn/T/markdown-68142ide15c.html#te-haskell" aria-hidden="true">
        <span aria-hidden="true" .octicon .octicon-link>
      Template Haskell
    <p>
      A contribution to Oliver Charles' 
      <a href="https://ocharles.org.uk/blog/">
        24 Days of GHC Extensions
      . You can find the submitted post here: 
      <a href="https://ocharles.org.uk/blog/guest-posts/2014-12-22-template-haskell.html">
        https://ocharles.org.uk/blog/guest-posts/2014-12-22-template-haskell.html
    <p>
      Template Haskell is an extension of Haskell 98 that allows for compile-time metaprogramming -- allowing one to directly convert back and forth between concrete Haskell syntax and the underlying abstract syntax tree (AST) of GHC. Anyone familiar with Lisp's macro system will immediately recognize the similarities -- though in Haskell, specific datatypes are used to represent an AST that is used to draw and splice back in code fragments. The ability to generate code at compile time allows one to implement macro-like expansions, polytypic programs, user directed optimization (such as inlining), and the generation of supporting data structures and functions from existing data structures and functions.
      <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/meta-haskell.pdf">
        1
    <p>
      In brief,  Oxford brackets 
      <code>
        [|
      and 
      <code>
        |]
      are used to get the abstract syntax tree for the enclosed expression and 'splice' brackets 
      <code>
        \$(
      and 
      <code>
        )
      are used to convert from the abstract syntax tree back into Haskell. The Quotation Monad is used to give unique names to the parsed tokens from the supplied Haskell code, and reification can be used to look up the name, type, constructor, and state of expression, and as well as the AST of Haskell types.
      <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html">
        4
    <p>
      Template Haskell was introduced by Tim Sheard and Simon Peyton Jones in their paper "Template Meta-Programming for Haskell" (The original paper can be found 
      <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/meta-haskell.pdf">
        here
      ) in 2002, though its changed quite a bit since (see 
      <a href="http://research.microsoft.com/en-us/um/people/simonpj/tmp/notes2.ps">
        here
      ). It was inspired by C++ templates, though TH is functionally more similar to a macro system. 
      <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Quote.html">
        Quasiquotation
      is often used in conjunction with Template Haskell, but makes up a pretty big section, so I will only briefly describe it here. Only another full article of its own, could do quasiquotation justice.
    <p>
      In the wild, Template Haskell is used extensively by Yesod for routing and HTML template binding.
      <a href="http://www.yesodweb.com/blog/2011/10/code-generation-conversation">
        8
      Outside of Haskell, compile-time metaprogramming is used for the creation of Domain Specific Languages (DSLs), typically in the domains of testing and modeling, and generative metaprogramming (compile-time or not) for object relational mapping, typically for mapping database schemas to non-compiled code. And within Lisp, which is famous for it's macro system, metaprogramming is used to create syntax extensions (syntactic sugar), such as the syntax used in lisp comprehensions.
      <a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html">
        3
    <hr>
    <p>
      <em>
        All code in this guide was executed with GHCi version 7.6.3 and Template Haskell version 2.9.0.0
    <p>
      To get started, start up GHCi with the Template Haskell extension by including 
      <code>
        -XTemplateHaskell
      , then load the AST datatypes:
    <div .highlight .highlight-source-shell>
      <pre>
        \$ ghci -XTemplateHaskell Prelude
        <span .pl-k>
          >
        :m + Language.Haskell.TH Prelude Language.Haskell.TH
        <span .pl-k>
          >
    <p>
      To see the AST syntax of some Haskell code insert valid Haskell syntax into oxford brackets and run it through 
      <code>
        runQ
      which stands for the Q monad (quotation monad):
    <div .highlight .highlight-source-shell>
      <pre>
        Prelude Language.Haskell.TH
        <span .pl-k>
          >
        runQ [
        <span .pl-k>
          |
        1 + 2 
        <span .pl-k>
          |
        ] InfixE (Just (LitE (IntegerL 1))) (VarE GHC.Num.+) (Just (LitE (IntegerL 2)))
    <p>
      If you parse through the parentheses you'll see the return expression forms a tree -- an abstract syntax tree! 
      <a href="https://github.com/seanwestfall/templatehaskell/blob/master/syntax_tree.png" target="_blank">
        <img src="./markdown-68142ide15c_files/syntax_tree.png" alt="abstract syntax tree" style="max-width:100%;">
    <p>
      Checkout the lift class 
      <a href="http://hackage.haskell.org/package/template-haskell-2.7.0.0/docs/src/Language-Haskell-TH-Syntax.html#Lift">
        source
      , which is what's being invoked by the oxford brackets. The Language.Haskell.TH.Syntax contains the definitions of all the types used in the AST. Using these types, it's possible to construct any fragment of the Haskell language. Have a look at the 
      <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lit">
        Lit
      data type as an example. Lit stands for literal,
    <div .highlight .highlight-source-haskell>
      <pre>
        <span .pl-k>
          data
        <span .pl-c1>
          Lit
        <span .pl-k>
          =
        <span .pl-c1>
          CharL
        <span .pl-c1>
          Char
        <span .pl-k>
          |
        <span .pl-c1>
          StringL
        <span .pl-c1>
          String
        <span .pl-k>
          |
        <span .pl-c1>
          IntegerL
        <span .pl-c1>
          Integer
        <span .pl-c>
          -- ^ Used for overloaded and non-overloaded
        <span .pl-c>
          -- literals. We don't have a good way to
        <span .pl-c>
          -- represent non-overloaded literals at
        <span .pl-c>
          -- the moment. Maybe that doesn't matter?
        <span .pl-k>
          |
        <span .pl-c1>
          RationalL
        <span .pl-c1>
          Rational
        <span .pl-c>
          -- Ditto
        <span .pl-k>
          |
        <span .pl-c1>
          IntPrimL
        <span .pl-c1>
          Integer
        <span .pl-k>
          |
        <span .pl-c1>
          WordPrimL
        <span .pl-c1>
          Integer
        <span .pl-k>
          |
        <span .pl-c1>
          FloatPrimL
        <span .pl-c1>
          Rational
        <span .pl-k>
          |
        <span .pl-c1>
          DoublePrimL
        <span .pl-c1>
          Rational
        <span .pl-k>
          |
        <span .pl-c1>
          StringPrimL
        <span .pl-c1>
          String
        <span .pl-c>
          -- ^ A primitive C-style string, type Addr#
        <span .pl-k>
          deriving
        ( 
        <span .pl-e>
          Show
        , 
        <span .pl-e>
          Eq
        , 
        <span .pl-e>
          Data
        , 
        <span .pl-e>
          Typeable
        )
    <p>
      tokens represented by it make up literals defined throughout your syntax in the AST, as you can see in our example AST above. Within Language.Haskell.TH.syntax, 35 generic data types are declared with the 
      <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Data.html">
        Data.Data
      module. If you're curious about what the AST syntax is referring to study the 
      <a href="http://hackage.haskell.org/package/template-haskell-2.7.0.0/docs/src/Language-Haskell-TH-Syntax.html#line-716">
        source
      .
    <p>
      The 
      <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#t:Q">
        Q
      monad handles the expression's typing via context, and also gives it a unique 
      <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/src/Language-Haskell-TH-Syntax.html#newName">
        name
      by appending an integer at the end of the expression name to handle scoping distinction. Quotations are lexically scoped and the Q monad handles this using it's naming scheme. (see the user's guide 
      <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html">
        wiki
      for a more in depth explanation of TH's lexical scoping).
    <p>
      Let's bind the returned AST expression from the example above to Haskell and evaluate it, using the splice brackets:
    <div .highlight .highlight-source-shell>
      <pre>
        Prelude Language.Haskell.TH
        <span .pl-k>
          >
        <span .pl-s>
          <span .pl-pds>
            \$(
          <span .pl-k>
            return
          (InfixE (Just (LitE (IntegerL 1))) (VarE (mkName 
          <span .pl-s>
            <span .pl-pds>
              "
            +
            <span .pl-pds>
              "
          )) (Just (LitE (IntegerL 2))))
          <span .pl-pds>
            )
        3
    <p>
      Ta da, you converted concrete Haskell to AST and then evaluated it. Though, as you can see, identifiers have to be defined with the 
      <code>
        mkName
      type in the AST to evaluate properly.
    <p>
      It's possible to avoid having to modify the AST to splice it back, but you'll have to bind it to a variable, as my next example illustrates:
    <p>
      In this example, the Fibonacci sequence is generated using zipWith:
      <a href="http://quasimal.com/posts/2012-05-25-quasitext-and-quasiquoting.html">
        2
    <div .highlight .highlight-source-haskell>
      <pre>
        <span .pl-k>
          let
        fibs 
        <span .pl-k>
          ::
        [
        <span .pl-c1>
          Integer
        ]     fibs 
        <span .pl-k>
          =
        <span .pl-c1>
          0
        <span .pl-k>
          :
        <span .pl-c1>
          1
        <span .pl-k>
          :
        <span .pl-c1>
          zipWith
        <span .pl-en>
          (+)
        fibs (
        <span .pl-c1>
          tail
        fibs)  
        <span .pl-k>
          let
        fibQ 
        <span .pl-k>
          ::
        <span .pl-c1>
          Int
        <span .pl-k>
          ->
        <span .pl-c1>
          Q
        <span .pl-c1>
          Exp
        fibQ n 
        <span .pl-k>
          =
        [
        <span .pl-k>
          |
        fibs 
        <span .pl-k>
          !!
        n 
        <span .pl-k>
          |
        ]
    <p>
      Now run 
      <code>
        \$( ... )
      to excute the expansion:
    <div .highlight .highlight-source-shell>
      <pre>
        Prelude Language.Haskell.TH
        <span .pl-k>
          >
        <span .pl-s>
          <span .pl-pds>
            \$(
          fibQ 22
          <span .pl-pds>
            )
        17711
    <p>
      TH splices in the expression that 
      <code>
        fibQ
      represents along with the variable (that is 
      <code>
        fibs !! n
      ).
    <p>
      Note, expressions and splices can be nested:
    <div .highlight .highlight-source-shell>
      <pre>
        Prelude Language.Haskell.TH
        <span .pl-k>
          >
        <span .pl-s>
          <span .pl-pds>
            \$(
          runQ [
          <span .pl-k>
            |
          fibs 
          <span .pl-k>
            !!
          <span .pl-s>
            <span .pl-pds>
              \$(
            [
            <span .pl-k>
              |
            8 
            <span .pl-k>
              |
            ]
            <span .pl-pds>
              )
          <span .pl-k>
            |
          ]
          <span .pl-pds>
            )
        21
    <p>
      I'll explain TH's syntax next -- but after, I'll show some more impressive examples that show the possibilities of splicing and ASTs.
    <h4>
      <a #user-content-syntax .anchor href="file:///var/folders/6n/t563zg9s3v78qtnjndr5f5gh0000gn/T/markdown-68142ide15c.html#syntax" aria-hidden="true">
        <span aria-hidden="true" .octicon .octicon-link>
      Syntax
    <p>
      Template Haskell quotation expression come with 4 different parser types, and an extensive 5th optional type that allows one to define their own types of quotations, called quasi-quotations.
    <ul>
      <li>
        <p>
          <code>
            [| ... |]
          , or 
          <code>
            [e| ... |]
          , generates expression AST syntax; it has the type 
          <code>
            Q Exp
          .
        <div .highlight .highlight-source-shell>
          <pre>
            Prelude Language.Haskell.TH
            <span .pl-k>
              >
            runQ [
            <span .pl-k>
              |
            1 + 2 
            <span .pl-k>
              |
            ] InfixE (Just (LitE (IntegerL 1))) (VarE GHC.Num.+) (Just (LitE (IntegerL 2)))
      <li>
        <p>
          <code>
            [d| ... |]
          , generates a list of top-level declaration AST sytnax; it has the type 
          <code>
            Q [Dec]
          .
        <div .highlight .highlight-source-shell>
          <pre>
            Prelude Language.Haskell.TH
            <span .pl-k>
              >
            runQ [d
            <span .pl-k>
              |
            x 
            <span .pl-k>
              =
            5
            <span .pl-k>
              |
            ] [ValD (VarP x_4) (NormalB (LitE (IntegerL 5))) []]
      <li>
        <p>
          <code>
            [t| ... |]
          , generates a type AST syntax; it has the type 
          <code>
            Q Type
          .
        <div .highlight .highlight-source-shell>
          <pre>
            Prelude Language.Haskell.TH
            <span .pl-k>
              >
            runQ [t
            <span .pl-k>
              |
            Int
            <span .pl-k>
              |
            ] ConT GHC.Types.Int
      <li>
        <p>
          <code>
            [p| ... |]
          , generates a pattern AST syntax; it has the type 
          <code>
            Q Pat
          .
        <div .highlight .highlight-source-shell>
          <pre>
            Prelude Language.Haskell.TH
            <span .pl-k>
              >
            runQ [p
            <span .pl-k>
              |
            (x,y)
            <span .pl-k>
              |
            ] TupP [VarP x_5,VarP y_6]
      <li>
        <p>
          Custom "quasi-quotations", have the form 
          <code>
            ["quoter"| ... |]
          . The "quoter" can be anything except e, d, t, and p, and the token cannot contain spaces. Though, all GHC is doing is determining which parser to use based on the context within the oxford brackets.
          <a href="https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md">
            7
        <p>
          Quasi-quotations is a big second part to meta-programming. They're essentially what makes it possible to write DSLs. I'm not going to cover it here since this guide is pretty long as it is, but if you're interested, there are many guides to using quasi-quotations, find them 
          <a href="https://www.cs.drexel.edu/~mainland/publications/mainland07quasiquoting.pdf">
            here
          , 
          <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html#th-quasiquotation">
            here
          , and 
          <a href="https://www.fpcomplete.com/user/marcin/quasiquotation-101">
            here
          (this one assumes you're familiar with Parsec parsing).
    <p>
      An important restriction on Template Haskell to remember is 
      <em>
        when inside a splice you can only call functions defined in imported modules, not functions defined elsewhere in the same module.
      Quotations and splice have to be defined in separate modules, otherwise you'll see this error:
    <div .highlight .highlight-source-shell>
      <pre>
        GHC stage restriction:   
        <span .pl-s>
          <span .pl-pds>
            `
          ...
          <span .pl-s>
            <span .pl-pds>
              '
            is used in a top-level splice or annotation,
        <span .pl-s>
          <span .pl-s>
            and must be imported, not defined locally
    <p>
      Though, if you're just binding variables in GHCi with 
      <code>
        let
      , you don't have to worry about this -- only when you're compiling Haskell.
    <h4>
      <a #user-content-debugging-and-reification .anchor href="file:///var/folders/6n/t563zg9s3v78qtnjndr5f5gh0000gn/T/markdown-68142ide15c.html#debugging-and-reification" aria-hidden="true">
        <span aria-hidden="true" .octicon .octicon-link>
      Debugging and Reification
    <p>
      You're probably wondering if you can evaluate a Q expression the other way, to see what the splice is evaluating. Of course you can -- run 
      <code>
        runQ(Q exp) >>= putStrLn.pprint
      to see what an expression with a 
      <code>
        Q Exp
      type will evaluate to:
    <div .highlight .highlight-source-shell>
      <pre>
        Prelude Language.Haskell.TH
        <span .pl-k>
          >
        <span .pl-c1>
          let
        myExp :: Q Exp
        <span .pl-k>
          ;
        myExp = runQ [
        <span .pl-k>
          |
        1 + 2 
        <span .pl-k>
          |
        ] Prelude Language.Haskell.TH
        <span .pl-k>
          >
        runQ(myExp) 
        <span .pl-k>
          >>
        = putStrLn.pprint 1 GHC.Num.+ 2
    <p>
      If you want to see the expansion of splices, use the flag 
      <code>
        -ddump-splices
      when starting GHCi : 
      <code>
        ghci -XTemplateHaskell -ddump-splices
      .
    <p>
      Now let's test it on another fun example with primes:
      <a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html">
        3
    <div .highlight .highlight-source-haskell>
      <pre>
        <span .pl-k>
          let
        isPrime 
        <span .pl-k>
          ::
        (
        <span .pl-c1>
          Integral
        a) 
        <span .pl-k>
          =>
        a 
        <span .pl-k>
          ->
        <span .pl-c1>
          Bool
        isPrime k 
        <span .pl-k>
          |
        k 
        <span .pl-k>
          \<=
        <span .pl-c1>
          1
        <span .pl-k>
          =
        <span .pl-c1>
          False
        <span .pl-k>
          |
        <span .pl-c1>
          otherwise
        <span .pl-k>
          =
        <span .pl-c1>
          not
        <span .pl-k>
          \$
        <span .pl-c1>
          elem
        <span .pl-c1>
          0
        (
        <span .pl-c1>
          map
        (
        <span .pl-c1>
          mod
        k)[
        <span .pl-c1>
          2
        <span .pl-k>
          ..
        k
        <span .pl-k>
          -
        <span .pl-c1>
          1
        ])  
        <span .pl-k>
          let
        nextPrime 
        <span .pl-k>
          ::
        (
        <span .pl-c1>
          Integral
        a) 
        <span .pl-k>
          =>
        a 
        <span .pl-k>
          ->
        a     nextPrime n 
        <span .pl-k>
          |
        isPrime n 
        <span .pl-k>
          =
        n 
        <span .pl-k>
          |
        <span .pl-c1>
          otherwise
        <span .pl-k>
          =
        nextPrime (n
        <span .pl-k>
          +
        <span .pl-c1>
          1
        )  
        <span .pl-c>
          -- returns a list of all primes between n and m, using the nextPrime function
        <span .pl-k>
          let
        doPrime 
        <span .pl-k>
          ::
        (
        <span .pl-c1>
          Integral
        a) 
        <span .pl-k>
          =>
        a 
        <span .pl-k>
          ->
        a 
        <span .pl-k>
          ->
        [a]     doPrime n m         
        <span .pl-k>
          |
        curr 
        <span .pl-k>
          >
        m 
        <span .pl-k>
          =
        <span .pl-c1>
          []
        <span .pl-k>
          |
        <span .pl-c1>
          otherwise
        <span .pl-k>
          =
        curr
        <span .pl-k>
          :
        doPrime (curr
        <span .pl-k>
          +
        <span .pl-c1>
          1
        ) m         
        <span .pl-k>
          where
        curr 
        <span .pl-k>
          =
        nextPrime n  
        <span .pl-c>
          -- and our Q expression
        <span .pl-k>
          let
        primeQ 
        <span .pl-k>
          ::
        <span .pl-c1>
          Int
        <span .pl-k>
          ->
        <span .pl-c1>
          Int
        <span .pl-k>
          ->
        <span .pl-c1>
          Q
        <span .pl-c1>
          Exp
        primeQ n m 
        <span .pl-k>
          =
        [
        <span .pl-k>
          |
        doPrime n m 
        <span .pl-k>
          |
        ]
    <div .highlight .highlight-source-shell>
      <pre>
        Prelude Language.Haskell.TH
        <span .pl-k>
          >
        <span .pl-s>
          <span .pl-pds>
            \$(
          primeQ 0 67
          <span .pl-pds>
            )
        <span .pl-k>
          \<
        interactive
        <span .pl-k>
          >
        :18:3-13: Splicing expression     primeQ 0 67 ======
        <span .pl-k>
          >
        doPrime 0 67 [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67]
    <p>
      Try it on a nested expression, to really see how useful the dump-splices flag is:
    <div .highlight .highlight-source-shell>
      <pre>
        Prelude Language.Haskell.TH
        <span .pl-k>
          >
        <span .pl-s>
          <span .pl-pds>
            \$(
          primeQ (
          <span .pl-s>
            <span .pl-pds>
              \$(
            primeQ 0 23
            <span .pl-pds>
              )
          <span .pl-k>
            !!
          3) 167
          <span .pl-pds>
            )
        <span .pl-k>
          \<
        interactive
        <span .pl-k>
          >
        :20:13-23: Splicing expression     primeQ 0 23 ======
        <span .pl-k>
          >
        doPrime 0 23 
        <span .pl-k>
          \<
        interactive
        <span .pl-k>
          >
        :20:3-34: Splicing expression     primeQ (
        <span .pl-s>
          <span .pl-pds>
            \$(
          primeQ 0 23
          <span .pl-pds>
            )
        <span .pl-k>
          !!
        3) 167 ======
        <span .pl-k>
          >
        doPrime 7 167 [7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167]
    <p>
      <code>
        -ddump-splices
      and 
      <code>
        >>= putStrLn.pprint
      should come in handy when debugging.
    <p>
      Now for probably, what I consider to be the hardest aspect of Template Haskell to understand -- reification.
    <p>
      Reification allows one to query the state of Haskell 
      <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#t:Name">
        <code>
          Name
      s and get information about them. Specifically, reify returns a data type called 
      <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#t:Info">
        <code>
          info
      -- which returns data in a specific format on any 
      <code>
        Name
      in Haskell, where the format and information depends on whether it's being interpreted in a type context or an expression context.
    <p>
      TH introduces two new identifiers specifically for reification: Prefix 
      <code>
        Name
      s to be evaluted in an expression context with a single quote, and prefix 
      <code>
        Name
      s to be evaluated in a type context with a double quote. Though, 
      <code>
        Name
      s must be interpretable within those contexts to be reified. (If you intend to use reify on expressions, don't use quotes in the names of those expressions -- otherwise it won't parse correctly.)
    <p>
      To use reify on a type, use double quotes:
    <div .highlight .highlight-source-shell>
      <pre>
        Prelude Language.Haskell.TH
        <span .pl-k>
          >
        <span .pl-s>
          <span .pl-pds>
            \$(
          stringE 
          <span .pl-c1>
            .
          show =
          <span .pl-k>
            \<<
          reify 
          <span .pl-s>
            <span .pl-pds>
              '
            <span .pl-pds>
              '
          Bool
          <span .pl-pds>
            )
        <span .pl-s>
          <span .pl-pds>
            "
          TyConI (DataD [] GHC.Types.Bool [] [NormalC GHC.Types.False [],NormalC GHC.Types.True []] [])
          <span .pl-pds>
            "
    <p>
      Reifying a type returns the AST as represented by TH, here's the AST in a diagram of the boolean type from above: 
      <a href="https://github.com/seanwestfall/templatehaskell/blob/master/syntax_tree_bool.png" target="_blank">
        <img src="./markdown-68142ide15c_files/syntax_tree_bool.png" alt="abstract syntax tree boolean" style="max-width:100%;">
    <p>
      The AST of a simple primitive type like Bool produces a small tree, but when used on types deeper down the module chain, relatively large ASTs will be generated. Try reify on 
      <code>
        ''Lit
      or 
      <code>
        ''Exp
      to know what I mean, though reify can work on any Haskell type.
    <p>
      To reify an expression, use single quotes, here's an example with our 
      <code>
        primeQ
      expression from above:
    <div .highlight .highlight-source-shell>
      <pre>
        Prelude Language.Haskell.TH
        <span .pl-k>
          >
        <span .pl-s>
          <span .pl-pds>
            \$(
          stringE 
          <span .pl-c1>
            .
          show =
          <span .pl-k>
            \<<
          reify 
          <span .pl-s>
            <span .pl-pds>
              '
            primeQ)
        <span .pl-s>
          <span .pl-s>
            "VarI primeQ_1627395913 (AppT (AppT ArrowT (ConT GHC.Types.Int)) (AppT (AppT ArrowT (ConT GHC.Types.Int)) (AppT (ConT Language.Haskell.TH.Syntax.Q) (ConT Language.Haskell.TH.Syntax.Exp)))) Nothing (Fixity 9 InfixL)"
    <p>
      As you can see 
      <code>
        info
      returns different information depending on whether it's a type or an expression. A type returns its structure in TH's AST syntax. An expression returns information regarding its name, type, it's constructor, and it's fixity.
    <p>
      Use reification of expressions to extract the types associated with the construction of an expression, then reify those types to get its structure in an AST. This allows one to generate the AST of any data type in Haskell -- no matter how deep into Haskell it gets.
    <p>
      Reification is very useful from the standpoint of what one can do with an AST to draw and splice back in code fragments within a programming language. Below, in Examples, the second example shows how one can use reify to extract the types from a record's constructor to write a generic Show function that can generate a 
      <code>
        Show
      for any record.
    <h4>
      <a #user-content-examples .anchor href="file:///var/folders/6n/t563zg9s3v78qtnjndr5f5gh0000gn/T/markdown-68142ide15c.html#examples" aria-hidden="true">
        <span aria-hidden="true" .octicon .octicon-link>
      Examples
    <p>
      A good example to show what one can do with Template Haskell is a type safe Haskell version of c's printf function (from 
      <a href="http://www.gnu.org/software/libc/manual/html_node/Formatted-Output-Functions.html">
        stdio.h
      ):
      <a href="https://www.haskell.org/haskellwiki/Template_Haskell">
        5
    <p>
      <em>
        Main.hs
    <div .highlight .highlight-source-haskell>
      <pre>
        {-# 
        <span .pl-k>
          LANGUAGE
        TemplateHaskell #-}  
        <span .pl-c>
          -- Import our template "printf"
        <span .pl-k>
          import
        <span .pl-c1>
          PrintF
        (
        <span .pl-en>
          printf
        )  
        <span .pl-c>
          -- The splice operator $ takes the Haskell source code
        <span .pl-c>
          -- generated at compile time by "printf" and splices it into
        <span .pl-c>
          -- the argument of "putStrLn".
        main 
        <span .pl-k>
          =
        <span .pl-k>
          do
        <span .pl-c1>
          putStrLn
        <span .pl-k>
          \$
        <span .pl-k>
          \$
        (printf 
        <span .pl-s>
          <span .pl-pds>
            "
          Hello %s %%x%% %d %%x%%
          <span .pl-pds>
            "
        ) 
        <span .pl-s>
          <span .pl-pds>
            "
          World
          <span .pl-pds>
            "
        <span .pl-c1>
          12
        <span .pl-c1>
          putStrLn
        <span .pl-k>
          \$
        <span .pl-k>
          \$
        (printf 
        <span .pl-s>
          <span .pl-pds>
            "
          Hello %s %s %s %d
          <span .pl-pds>
            "
        ) 
        <span .pl-s>
          <span .pl-pds>
            "
          Russian
          <span .pl-pds>
            "
        <span .pl-s>
          <span .pl-pds>
            "
          with
          <span .pl-pds>
            "
        <span .pl-s>
          <span .pl-pds>
            "
          Love
          <span .pl-pds>
            "
        <span .pl-c1>
          5000
    <p>
      <em>
        PrintF.hs
    <div .highlight .highlight-source-haskell>
      <pre>
        {-# 
        <span .pl-k>
          LANGUAGE
        TemplateHaskell #-} 
        <span .pl-k>
          module
        <span .pl-c1>
          PrintF
        <span .pl-k>
          where
        <span .pl-c>
          -- NB: printf needs to be in a separate module to the one where
        <span .pl-c>
          -- you intend to use it.
        <span .pl-c>
          -- Import some Template Haskell syntax
        <span .pl-k>
          import
        <span .pl-c1>
          Language.Haskell.TH
        <span .pl-c>
          -- Possible string tokens: %d %s and literal strings
        <span .pl-k>
          data
        <span .pl-c1>
          Format
        <span .pl-k>
          =
        <span .pl-c1>
          D
        <span .pl-k>
          |
        <span .pl-c1>
          S
        <span .pl-k>
          |
        <span .pl-c1>
          L
        <span .pl-c1>
          String
        <span .pl-k>
          deriving
        <span .pl-c1>
          Show
        <span .pl-c>
          -- a poor man's tokenizer
        <span .pl-en>
          tokenize
        :: 
        <span .pl-c1>
          String
        <span .pl-k>
          ->
        [
        <span .pl-k>
          Format
        ] tokenize 
        <span .pl-c1>
          []
        <span .pl-k>
          =
        <span .pl-c1>
          []
        tokenize (
        <span .pl-s>
          <span .pl-pds>
            '
          %
          <span .pl-pds>
            '
        <span .pl-k>
          :
        c
        <span .pl-k>
          :
        rest) 
        <span .pl-k>
          |
        c 
        <span .pl-k>
          ==
        <span .pl-s>
          <span .pl-pds>
            '
          d
          <span .pl-pds>
            '
        <span .pl-k>
          =
        <span .pl-c1>
          D
        <span .pl-k>
          :
        tokenize rest                       
        <span .pl-k>
          |
        c 
        <span .pl-k>
          ==
        <span .pl-s>
          <span .pl-pds>
            '
          s
          <span .pl-pds>
            '
        <span .pl-k>
          =
        <span .pl-c1>
          S
        <span .pl-k>
          :
        tokenize rest tokenize (s
        <span .pl-k>
          :
        str) 
        <span .pl-k>
          =
        <span .pl-c1>
          L
        (s
        <span .pl-k>
          :
        p) 
        <span .pl-k>
          :
        tokenize rest 
        <span .pl-c>
          -- so we don't get stuck on weird '%'
        <span .pl-k>
          where
        (p,rest) 
        <span .pl-k>
          =
        <span .pl-c1>
          span
        (
        <span .pl-k>
          /=
        <span .pl-s>
          <span .pl-pds>
            '
          %
          <span .pl-pds>
            '
        ) str  
        <span .pl-c>
          -- generate argument list for the function
        <span .pl-en>
          args
        :: [
        <span .pl-k>
          Format
        ] 
        <span .pl-k>
          ->
        [
        <span .pl-k>
          PatQ
        ] args fmt 
        <span .pl-k>
          =
        <span .pl-c1>
          concatMap
        (
        <span .pl-k>
          \
        (f,n) 
        <span .pl-k>
          ->
        <span .pl-k>
          case
        f 
        <span .pl-k>
          of
        <span .pl-c1>
          L
        _ 
        <span .pl-k>
          ->
        <span .pl-c1>
          []
        _   
        <span .pl-k>
          ->
        [varP n]) 
        <span .pl-k>
          \$
        <span .pl-c1>
          zip
        fmt names     
        <span .pl-k>
          where
        names 
        <span .pl-k>
          =
        [ mkName 
        <span .pl-k>
          \$
        <span .pl-s>
          <span .pl-pds>
            '
          x
          <span .pl-pds>
            '
        <span .pl-k>
          :
        <span .pl-c1>
          show
        i 
        <span .pl-k>
          |
        i 
        <span .pl-k>
          \<-
        [
        <span .pl-c1>
          0
        <span .pl-k>
          ..
        ] ]  
        <span .pl-c>
          -- generate body of the function
        <span .pl-en>
          body
        :: [
        <span .pl-k>
          Format
        ] 
        <span .pl-k>
          ->
        <span .pl-k>
          ExpQ
        body fmt 
        <span .pl-k>
          =
        <span .pl-c1>
          foldr
        (
        <span .pl-k>
          \
        e e' 
        <span .pl-k>
          ->
        infixApp e [
        <span .pl-k>
          |
        <span .pl-en>
          (++)
        <span .pl-k>
          |
        ] e') (
        <span .pl-c1>
          last
        exps) (
        <span .pl-c1>
          init
        exps)     
        <span .pl-k>
          where
        exps 
        <span .pl-k>
          =
        [ 
        <span .pl-k>
          case
        f 
        <span .pl-k>
          of
        <span .pl-c1>
          L
        s 
        <span .pl-k>
          ->
        stringE s                     
        <span .pl-c1>
          D
        <span .pl-k>
          ->
        appE [
        <span .pl-k>
          |
        <span .pl-c1>
          show
        <span .pl-k>
          |
        ] (varE n)                     
        <span .pl-c1>
          S
        <span .pl-k>
          ->
        varE n                  
        <span .pl-k>
          |
        (f,n) 
        <span .pl-k>
          \<-
        <span .pl-c1>
          zip
        fmt names ]           names 
        <span .pl-k>
          =
        [ mkName 
        <span .pl-k>
          \$
        <span .pl-s>
          <span .pl-pds>
            '
          x
          <span .pl-pds>
            '
        <span .pl-k>
          :
        <span .pl-c1>
          show
        i 
        <span .pl-k>
          |
        i 
        <span .pl-k>
          \<-
        [
        <span .pl-c1>
          0
        <span .pl-k>
          ..
        ] ]  
        <span .pl-c>
          -- glue the argument list and body together into a lambda
        <span .pl-c>
          -- this is what gets spliced into the haskell code at the call
        <span .pl-c>
          -- site of "printf"
        <span .pl-en>
          printf
        :: 
        <span .pl-c1>
          String
        <span .pl-k>
          ->
        <span .pl-k>
          Q
        <span .pl-k>
          Exp
        printf format 
        <span .pl-k>
          =
        lamE (args fmt) (body fmt)     
        <span .pl-k>
          where
        fmt 
        <span .pl-k>
          =
        tokenize format
    <p>
      Notice that we had to separate the splicing and the expression definitions in separate modules, as mentioned in the syntax section above.
    <p>
      Compile the following with:
    <div .highlight .highlight-source-shell>
      <pre>
        \$ ghc --make Main.hs -o main
    <p>
      running main will print out:
    <div .highlight .highlight-source-shell>
      <pre>
        \$ ./main Hello World %%x%% 22 %%x%% Hello Russian with Love 5000
    <p>
      Now for an example that shows what one can do with reify -- a Generic Show that can produce a 
      <code>
        Show
      for any record type:
      <a href="http://web.archive.org/web/20100703060856/http://www.haskell.org/bz/thdoc.htm">
        6
    <p>
      <em>
        Main.hs
    <div .highlight .highlight-source-haskell>
      <pre>
        <span .pl-c>
          {- Main.hs -}
        <span .pl-k>
          module
        <span .pl-c1>
          Main
        <span .pl-k>
          where
        <span .pl-k>
          import
        <span .pl-c1>
          Derive
        <span .pl-k>
          data
        <span .pl-c1>
          T
        <span .pl-k>
          =
        <span .pl-c1>
          A
        <span .pl-c1>
          Int
        <span .pl-c1>
          String
        <span .pl-k>
          |
        <span .pl-c1>
          B
        <span .pl-c1>
          Integer
        <span .pl-k>
          |
        <span .pl-c1>
          C
        <span .pl-k>
          \$
        (deriveShow ''
        <span .pl-c1>
          T
        )  main 
        <span .pl-k>
          =
        <span .pl-c1>
          print
        [
        <span .pl-c1>
          A
        <span .pl-c1>
          1
        <span .pl-s>
          <span .pl-pds>
            "
          s
          <span .pl-pds>
            "
        , 
        <span .pl-c1>
          B
        <span .pl-c1>
          2
        , 
        <span .pl-c1>
          C
        ]  
        <span .pl-c>
          -- prints exactly <<[A 1 "s",B 2,C]>>
    <p>
      <em>
        Derive.hs
    <div .highlight .highlight-source-haskell>
      <pre>
        <span .pl-c>
          {- Derive.hs -}
        <span .pl-k>
          module
        <span .pl-c1>
          Derive
        <span .pl-k>
          where
        <span .pl-k>
          import
        <span .pl-c1>
          Language.Haskell.TH
        <span .pl-k>
          import
        <span .pl-c1>
          Control.Monad
        <span .pl-k>
          data
        <span .pl-c1>
          T1
        <span .pl-k>
          =
        <span .pl-c1>
          T1
        <span .pl-k>
          data
        <span .pl-c1>
          T2
        a 
        <span .pl-k>
          =
        <span .pl-c1>
          T2
        a  deriveShow t 
        <span .pl-k>
          =
        <span .pl-k>
          do
        <span .pl-c>
          -- Get list of constructors for type t
        <span .pl-c1>
          TyConI
        (
        <span .pl-c1>
          DataD
        _ _ _ constructors _)  
        <span .pl-k>
          \<-
        reify t    
        <span .pl-c>
          -- Make `show` clause for one constructor:
        <span .pl-c>
          --   show (A x1 x2) = "A "++show x1++" "++show x2
        <span .pl-k>
          let
        showClause (
        <span .pl-c1>
          NormalC
        name fields) 
        <span .pl-k>
          =
        <span .pl-k>
          do
        <span .pl-c>
          -- Name of constructor, i.e. "A". Will become string literal in generated code
        <span .pl-k>
          let
        constructorName 
        <span .pl-k>
          =
        nameBase name         
        <span .pl-c>
          -- Get variables for left and right side of function definition
        (pats,vars) 
        <span .pl-k>
          \<-
        genPE (
        <span .pl-c1>
          length
        fields)         
        <span .pl-c>
          -- Recursively build (" "++show x1++...++"") expression from [x1...] variables list
        <span .pl-k>
          let
        f 
        <span .pl-c1>
          []
        <span .pl-k>
          =
        [
        <span .pl-k>
          |
        <span .pl-s>
          <span .pl-pds>
            "
          <span .pl-pds>
            "
        <span .pl-k>
          |
        ]             f (v
        <span .pl-k>
          :
        vars) 
        <span .pl-k>
          =
        [
        <span .pl-k>
          |
        <span .pl-s>
          <span .pl-pds>
            "
          <span .pl-pds>
            "
        <span .pl-k>
          ++
        <span .pl-c1>
          show
        <span .pl-k>
          \$
        v 
        <span .pl-k>
          ++
        <span .pl-k>
          \$
        (f vars) 
        <span .pl-k>
          |
        ]         
        <span .pl-c>
          -- Generate function clause for one constructor
        clause [conP name pats]                                 
        <span .pl-c>
          -- (A x1 x2)
        (normalB [
        <span .pl-k>
          |
        constructorName 
        <span .pl-k>
          ++
        <span .pl-k>
          \$
        (f vars) 
        <span .pl-k>
          |
        ]) 
        <span .pl-c1>
          []
        <span .pl-c>
          -- "A "++show x1++" "++show x2
        <span .pl-c>
          -- Make body for function `show`:
        <span .pl-c>
          --   show (A x1 x2) = "A "++show x1++" "++show x2
        <span .pl-c>
          --   show (B x1)    = "B "++show x1
        <span .pl-c>
          --   show C         = "C"
        showbody 
        <span .pl-k>
          \<-
        <span .pl-c1>
          mapM
        showClause constructors    
        <span .pl-c>
          -- Generate template instance declaration and then replace
        <span .pl-c>
          --   type name (T1) and function body (\x -> "text") with our data
        d 
        <span .pl-k>
          \<-
        [d
        <span .pl-k>
          |
        <span .pl-k>
          instance
        <span .pl-k>
          Show
        <span .pl-k>
          T1
        <span .pl-k>
          where
        <span .pl-c1>
          show
        x 
        <span .pl-k>
          =
        <span .pl-s>
          <span .pl-pds>
            "
          text
          <span .pl-pds>
            "
        <span .pl-k>
          |
        ]   
        <span .pl-k>
          let
        [
        <span .pl-c1>
          InstanceD
        <span .pl-c1>
          []
        (
        <span .pl-c1>
          AppT
        showt (
        <span .pl-c1>
          ConT
        _T1)) [
        <span .pl-c1>
          FunD
        showf _text]] 
        <span .pl-k>
          =
        d   
        <span .pl-c1>
          return
        [
        <span .pl-c1>
          InstanceD
        <span .pl-c1>
          []
        (
        <span .pl-c1>
          AppT
        showt (
        <span .pl-c1>
          ConT
        t  )) [
        <span .pl-c1>
          FunD
        showf showbody]]   
        <span .pl-c>
          -- Generate n unique variables and return them in form of patterns and expressions
        genPE n 
        <span .pl-k>
          =
        <span .pl-k>
          do
        ids 
        <span .pl-k>
          \<-
        replicateM n (newName 
        <span .pl-s>
          <span .pl-pds>
            "
          x
          <span .pl-pds>
            "
        )   
        <span .pl-c1>
          return
        (
        <span .pl-c1>
          map
        varP ids, 
        <span .pl-c1>
          map
        varE ids)
    <p>
      Compile the following with:
    <div .highlight .highlight-source-shell>
      <pre>
        \$ ghc --make Main.hs -o main
    <p>
      running main will print out:
    <div .highlight .highlight-source-shell>
      <pre>
        \$ ./main [A 1 
        <span .pl-s>
          <span .pl-pds>
            "
          s
          <span .pl-pds>
            "
        ,B 2,C]
    <h4>
      <a #user-content-conclusion .anchor href="file:///var/folders/6n/t563zg9s3v78qtnjndr5f5gh0000gn/T/markdown-68142ide15c.html#conclusion" aria-hidden="true">
        <span aria-hidden="true" .octicon .octicon-link>
      Conclusion
    <p>
      This guide was for the most part written from collecting information written in other guides on Template Haskell, quasi-quoting, and Lisp macros -- from online, wiki, and academic sources. Please check my bibliography to see where what came from what so credit can be properly given where it's due.
    <p>
      Meta-programming is a powerful programming technique that can allow for the generation of user generated syntax extensions and DSLs. This is useful in that it can allow a programmer to generate custom code generating syntax extensions without otherwise having to change the core language. Template Haskell in particular is especially powerful over similar programming language constructs (i.e. The C Preprocessor, Lisp's Macro system) in that it makes use of ASTs, reification (through a specific function), and -- much in the spirit of Haskell -- type-safety. The examples presented above only scratch the surface of what's possible with reification -- imagine the ability to construction entire systems, and then use reify to build ASTs, then swap in and out entire modules, entirely with the use of Template Haskell.
    <p>
      Some questions that have arisen within me from writing this article are: What are the limits of TH's data type system? Is it truly possible for TH to represent all of Haskell with the finite set of data types written into the module? Is it possible for future language features to defy this set? What are the limits of meta-programming -- TH, macros, and similar meta-prorgramming constructs make it possible to write code that writes code -- but are there limits to this -- is it possible to write a macro that can generate a macro, and so on indefinitely?
    <p>
      Don't forget to checkout the API. Everything you need to know, you can for the most part find in the 
      <a href="http://hackage.haskell.org/package/template-haskell-2.9.0.0/docs/Language-Haskell-TH-Syntax.html#t:Lit">
        source
      . Also TH does in fact have bugs, check the issue tracking page if you're dealing with a known issue: see 
      <a href="https://ghc.haskell.org/trac/ghc/query?status=new&status=assigned&status=reopened&component=Template+Haskell&order=priority">
        here
      .
    <h4>
      <a #user-content-bibliography .anchor href="file:///var/folders/6n/t563zg9s3v78qtnjndr5f5gh0000gn/T/markdown-68142ide15c.html#bibliography" aria-hidden="true">
        <span aria-hidden="true" .octicon .octicon-link>
      Bibliography
    <ol>
      <li>
        <p>
          Tim Sheard and Simon Peyton Jones, "Template meta-programming for Haskell," ACM SIGPLAN 2002 Haskell Workshop 3 (October 2002): 1-6, doi: 10.1145/581690.581691 
          <a href="http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/meta-haskell.pdf">
            http://research.microsoft.com/en-us/um/people/simonpj/papers/meta-haskell/meta-haskell.pdf
      <li>
        <p>
          Mike Ledger, "A look at QuasiQuotation," 2012.  
          <a href="http://quasimal.com/posts/2012-05-25-quasitext-and-quasiquoting.html">
            http://quasimal.com/posts/2012-05-25-quasitext-and-quasiquoting.html
      <li>
        <p>
          Peter Seibel, 
          <em>
            Practical Common Lisp
          (Apress, 2005) 
          <a href="http://www.gigamonkeys.com/book/macros-defining-your-own.html">
            http://www.gigamonkeys.com/book/macros-defining-your-own.html
      <li>
        <p>
          The Glorious Glasgow Haskell Compilation System User's Guide, Version 7.8.3, 2007  
          <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html">
            https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/template-haskell.html
      <li>
        <p>
          Template Haskell, Haskell Wiki, last updated October 2014:  
          <a href="https://www.haskell.org/haskellwiki/Template_Haskell">
            https://www.haskell.org/haskellwiki/Template_Haskell
      <li>
        <p>
          Unknown Author, Template Haskell doc, 
          <a href="http://web.archive.org/web/20100703060856/http://www.haskell.org/bz/thdoc.htm">
            http://web.archive.org/web/20100703060856/http://www.haskell.org/bz/thdoc.htm
      <li>
        <p>
          Sami Hangaslammi, Basic Tutorial of Template Haskell, 2011: 
          <a href="https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md">
            https://github.com/leonidas/codeblog/blob/master/2011/2011-12-27-template-haskell.md
      <li>
        <p>
          Greg Weber, Code that writes code and conversation about conversations, 2011: 
          <a href="http://www.yesodweb.com/blog/2011/10/code-generation-conversation">
            http://www.yesodweb.com/blog/2011/10/code-generation-conversation
    <h4>
      <a #user-content-license .anchor href="file:///var/folders/6n/t563zg9s3v78qtnjndr5f5gh0000gn/T/markdown-68142ide15c.html#license" aria-hidden="true">
        <span aria-hidden="true" .octicon .octicon-link>
      License
    <p>
      (The MIT License)
    <p>
      Copyright (c) 2014 Sean Westfall
    <p>
      Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the 'Software'), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
    <p>
      The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
    <p>
      THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE sOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
